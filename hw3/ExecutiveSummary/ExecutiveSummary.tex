\documentclass[journal]{IEEEtran}

\usepackage{graphicx}
\graphicspath{{public/}}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Format String Vulnerability for WebBench}
\author{Qiyang~Gu, Ujjawal~Sharma, Zhiyuan~Li}
\maketitle


\begin{abstract}
Format String Vulnerability is one of the most common vulnerabilities found in applications developed . It is one of those attacks which is considered to be as dangerous for any application. Attacker can get full control of the application or the data being handled by the application. This kind of vulnerability is mostly performed on the applications based on C programming languages. Many a times attackers use this vulnerability to crash the application and also to execute malicious code of their choice. The attacker gets the direct access to read and write into the memory addresses so he can use even the memory to either steal important information or inject false data.
\end{abstract}

\begin{IEEEkeywords}
Format String, Vulnerability, WebBench, Stress Testing
\end{IEEEkeywords}


\section{Introduction On WebBench}
\IEEEPARstart{W}ebBench is an open source application performance testing tool. It is mostly used for load testing where any particular application is stressed to potential traffic and then the performance of the application is evaluated under such stress. It is a very useful tool for eCommerce websites where sudden increase in traffic can be observed anytime. Multiple clients can request the provided application's URL at any given time as WebBench uses for() to simulate. 30k concurrent connections can be handled by WebBench easily at any given time, which makes it a unique tool. \cite{webbench_intro}

\section{Reasons on WebBench}
Performing the Format String Vulnerability requires a commonly known tool and a mature knowledge of C programming language. Selection of a software for performing this activity was very important for us and we did an intensive search on the applcations available on the open-source forums. Our choice of selecting this software was majorly influenced by the current ongoing scenarios. Every few days we come across a news saying some application has been found to be attacked by malicios codes. To get an overview of the scenarios leading to such attacks, it was important to understand how the attacks are being done and what are the ways to prevent it. WebBench is a performance testing software, so it couldn't have been better than assessing the performance of a performance testing application. Apart from this, WebBench is a lightweight tool which can be explored properly with. The lesser number of lines of codes in WebBench made us understand the application very well quickly and we were able to place the format specifier strings in a correct way.\\

What's more, WebBench is written in C and it accepts command line arguments. Therefore, putting together all these factors, we found it a perfect application to be a research target.

\section{Project Goals}
Below are the goals, which we had in our mind while performing this activity: \\
\begin{itemize}
\item To understand the architecture and main functions of WebBench and also to understand how Webbench works.
\item To understand what makes the format specifers so important in the study of vulnerabilities.
\item To understand the basic knowledge of how stack works in memory.
\item To understand the basic knowledge of gdb and gcc. To understand how to use them in terminal and in Eclipse.
\item To get familiar with the techniques already available, which can help us, exploit the format string vulnerabilities by creating an effective exploit code.
\item To get familiar with the overall process of basic bufferover flow attack, arbitrary write/read.
\end{itemize}

\section{Project Execution Highlights}
Firstly, we compile the source codes we get from \textit{github.com} to an executable file. We run the executable file and do some feature tests. The main function of WebBench is making requests to a specific URL. There are some parameters the users can set, like time, proxy, etc. \\
Here is the overview architecture diagram.

Secondly, we follow the instructions from the assignment, analyzing the binary files via Linux command line, like printing the library dependencies, listing symbols, etc. During this process, we get more detailed information about the binary files and the program. We generate a top-level system architectural diagram through the process. \\

Thirdly, we use \textit{SciTools Understand}\cite{understand} to analyze the program. We use \textit{buildspy} to build the binary and
simultaneously create an understand database. We import the database file in \textit{Understand} and we analyze the file. The charts generated by \textit{Understand} helps us understand the architecture in finer granularity. The control flow is really helpful. \\

Finally, we do reverse engineering on binary files. We use \textit{http://binvis.io}\cite{binvis} to analyze the content according to address. We also write a Python script to read the content in specific address, and print the content out.



\section{Accomplished \& Unaccomplished}
\subsection{Accomplished}
\begin{itemize}
\item Understood the architecture of WebBench. Got familiar with its functions.
\item Used gcc compiler and gcc linker to compile WebBench to the 32-bit x86 binary.
\item Used gdb within Eclipse to debug the program.
\item Understood the format string vulnerabilities and how to exploxit the vulnerabilities by:
\begin{itemize}
\item Implementing an information leak exploit.
\item Implementing an buffer overflow exploit.
\item Implementing an arbitrary write exploit.
\end{itemize}
\end{itemize}

\subsection{Unaccomplished}
\begin{itemize}
\item Did not understand all the section headers of the Webbench binary files.
\item Did not learn all the symbols of the Webbench binary files
\item Did not reverse the whole binary files of Webbench
\end{itemize}


\section{Conclusion}
In this homework, we analyze the binary file and source code of an open source software--WebBench, which is tool can analyze the benchmark of a web server. Firstly, we analyze the binary file, we analyze its section headers, symbols. Secondly, we analyze the source code through scitools Understand. Thirdly, we conduct the reverse engineering for the partial Webbench binary file. In conclusion, we get the basic knowledge to analyze the binary code by some Linux commands and we also know how to use the scitools Understand as well as get a broadened view of reverse engineering.

\begin{thebibliography}{10}
\bibitem{webbench_intro}
\"EZLippi/WebBench\", GitHub. [Online]. Available: https://github.com/EZLippi/WebBench.

\bibitem{binvis}
\"binvis.io\", Binvis.io. [Online]. Available: http://binvis.io.

\bibitem{understand}
\"SciTools.com\", Scitools.com. [Online]. Available: https://scitools.com/features/.

\end{thebibliography}

% \bibliographystyle{IEEEtran}
% \bibliography{test}

\end{document}