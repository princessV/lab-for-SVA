\documentclass[journal]{IEEEtran}

\usepackage{graphicx}
\graphicspath{{public/}}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Format String Vulnerability for WebBench}
\author{Qiyang~Gu, Ujjawal~Sharma, Zhiyuan~Li}
\maketitle


\begin{abstract}
Format String Vulnerability is one of the most common vulnerabilities found in applications developed . It is one of those attacks which is considered to be as dangerous for any application. Attacker can get full control of the application or the data being handled by the application. This kind of vulnerability is mostly performed on the applications based on C programming languages. Many a times attackers use this vulnerability to crash the application and also to execute malicious code of their choice. The attacker gets the direct access to read and write into the memory addresses so he can use even the memory to either steal important information or inject false data.
\end{abstract}

\begin{IEEEkeywords}
Reverse Engineering, WebBench, Stress Testing
\end{IEEEkeywords}


\section{Introduction On WebBench}
\IEEEPARstart{W}ebBench is an open source application performance testing tool. It is mostly used for load testing where any particular application is stressed to potential traffic and then the performance of the application is evaluated under such stress. Its a very useful tool for eCommerce websites where sudden increase in traffic can be observed anytime. Multiple clients can requests the provided application's URL at any given time as WebBench uses for() to simulate. 30k concurrent connections can be handled by WebBench easily at any given time, which makes it a unique tool. \cite{webbench_intro}

\section{Reasons on WebBench}
Performing the Format String Vulnerability requires a commonly known tool and a mature knowledge of C programming language. Selection of a software for performing this activity was very important for us and we did an intensive research on the available applcations available on the open-source forums. Our choice of selecting this software was majorly influenced by the current ongoing scenarios. Coming across news of server failure of e-Commerce giants like Amazon or Wal-Mart is definitely not a shocker these days. To understand the cause and the factors affecting this is altogether a different story, but at the same time it is also important to understand that how these issues are getting tackled in the real world and which all factors are supporting it. One of the best practices to avoid such server failures is doing a thorough testing of the environments before making it live. WebBench is one of such tools which can help the firms to assess the behavior of servers under cases of severe loads. Our main aim for performing this activity is to understand what algorithm and architecture the application is encapsulating, which is making it so successful against most of the odds, which can occur. \\

What's more, WebBench is a extremely lightweight tool, written totally by C. Therefore, it is a great research target for us to do reverse engineering.

\section{Project Goals}
Below are the goals, which we had in our mind while performing this activity: \\
\begin{itemize}
\item To understand the architecture of product.
\item To get familiar with the techniques already available, which can help us, do reverse engineering.
\item To get familiar with the overall process of reverse engineering.
\item To understand the meaning of reverse engineering in pratical work.
\item To get an idea on how to be more accurate while performing reverse engineering.
\end{itemize}

\section{Project Execution Highlights}
Firstly, we compile the source codes we get from \textit{github.com} to an executable file. We run the executable file and do some feature tests. The main function of WebBench is making requests to a specific URL. There are some parameters the users can set, like time, proxy, etc. \\
Here is the overview architecture diagram.
\begin{figure}[!htbp]
\centering

\caption{Overview}
\end{figure}

Secondly, we follow the instructions from the assignment, analyzing the binary files via Linux command line, like printing the library dependencies, listing symbols, etc. During this process, we get more detailed information about the binary files and the program. We generate a top-level system architectural diagram through the process. \\

Thirdly, we use \textit{SciTools Understand}\cite{understand} to analyze the program. We use \textit{buildspy} to build the binary and
simultaneously create an understand database. We import the database file in \textit{Understand} and we analyze the file. The charts generated by \textit{Understand} helps us understand the architecture in finer granularity. The control flow is really helpful. \\

Finally, we do reverse engineering on binary files. We use \textit{http://binvis.io}\cite{binvis} to analyze the content according to address. We also write a Python script to read the content in specific address, and print the content out.



\section{Accomplished \& Unaccomplished}
\subsection{Accomplished}
\begin{itemize}
\item  Compilation of binary.
\item  Dumping the headers.
\item  Printing the shared library dependencies.
\item  Printing the symbols.
\item  Dump vm tables at the time of execution.
\item  Able to run the strace and obtain the PID.
\item  Able to import the source code to SciTools Understand.
\item  Able to build the binary using buildspy.
\item  Able to print the metrics summary.
\item Able to capture Cluster Call Butterfly graph view.
\item Able to Identify vulnerabilities.
\item Able to plot the entropy of binary file.
\end{itemize}

\subsection{Unaccomplished}
\begin{itemize}
\item Did not understand all the section headers of the Webbench binary files.
\item Did not learn all the symbols of the Webbench binary files
\item Did not reverse the whole binary files of Webbench
\end{itemize}
\section{Conclusion}
In this homework, we analyze the binary file and source code of an open source software--WebBench, which is tool can analyze the benchmark of a web server. Firstly, we analyze the binary file, we analyze its section headers, symbols. Secondly, we analyze the source code through scitools Understand. Thirdly, we conduct the reverse engineering for the partial Webbench binary file. In conclusion, we get the basic knowledge to analyze the binary code by some Linux commands and we also know how to use the scitools Understand as well as get a broadened view of reverse engineering.

\begin{thebibliography}{10}
\bibitem{webbench_intro}
\"EZLippi/WebBench\", GitHub. [Online]. Available: https://github.com/EZLippi/WebBench.

\bibitem{binvis}
\"binvis.io\", Binvis.io. [Online]. Available: http://binvis.io.

\bibitem{understand}
\"SciTools.com\", Scitools.com. [Online]. Available: https://scitools.com/features/.

\end{thebibliography}

% \bibliographystyle{IEEEtran}
% \bibliography{test}

\end{document}