\documentclass[journal]{IEEEtran}


\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Exploitation of Buffer Overflow Vulnerability}
\author{Qiyang~Gu, Ujjawal~Sharma, Zhiyuan~Li}
\maketitle


\begin{abstract}
Stack Smash Exploit is caused when a programme is trying to access (read or write) a region of an array that is not bounded by it. Suppose an array has length 'n' and the programme is trying to access its n+1\textsuperscript{th} location, in this case an overflow of stack will occur. This happens in the C and C++ programming languages. The reason behind such an occurance is that the runtime environment of these programming language do not provide a check on the buffer overflow. However, in other programming languages such as Java, Pascal, C-Sharp etc., the runtime environment do take care of buffer overflow. There are some functions in C such as strcpy and gets which does not include array bound checks and thus can lead to some major attacks. Attckers use this vulnerability to modify the execution of programme in the way they want. The attacker may take up the complete control of execution of the programme by using this vulnerability.
\end{abstract}

\begin{IEEEkeywords}
 stacksmash, bufferoverflow, Vulnerability, Exploit
\end{IEEEkeywords}


\section{Introduction}
\IEEEPARstart{F}or demonstrating the exploit, we have created our own C programmes.  \cite{webbench_intro}

\section{Reasons and Goals}
Performing the Format String Vulnerability requires a commonly known tool and a mature knowledge of C programming language. Selection of a software for performing this activity was very important for us and we did an intensive search on the applcations available on the open-source forums. Our choice of selecting this software was majorly influenced by the current ongoing scenarios. Every few days we come across a news saying some application has been found to be attacked by malicios codes. To get an overview of the scenarios leading to such attacks, it was important to understand how the attacks are being done and what are the ways to prevent it. WebBench is a performance testing software, so it couldn't have been better than assessing the performance of a performance testing application. Apart from this, WebBench is a lightweight tool which can be explored properly with. The lesser number of lines of codes in WebBench made us understand the application very well quickly and we were able to place the format specifier strings in a correct way.

What's more, WebBench is written in C and it accepts command line arguments. Therefore, putting together all these factors, we found it a perfect application to be a research target.

Below are the goals, which we had in our mind while performing this activity:
\begin{itemize}
\item To understand the architecture and main functions of WebBench and also to understand how Webbench works.
\item To understand what makes the format specifers so important in the study of vulnerabilities.
\item To understand the basic knowledge of how stack works in memory.
\item To understand the basic knowledge of gdb and gcc. To understand how to use them in terminal and in Eclipse.
\item To get familiar with the techniques already available, which can help us, exploit the format string vulnerabilities by creating an effective exploit code.
\item To get familiar with the overall process of basic bufferover flow attack, arbitrary write/read.
\end{itemize}

\section{Project Execution Highlights}
\subsection{Implementing a stack smashing exploit that uses shellcode injection}
Firstly, we review the knowledge in class that how to exploit a bufferoverflow vulnerability and take advantage of this vulnerability to conduct stack smashing. We review the structure of a stack and how it changes when it executes the function call procedure. Based on this, we learn to how to exploit stack smashing by code injection and arc injection and we aquire some basic understanding about how these two exploits work, and what's the difference between these two exploits. For the code injection, we know that we need to construct a vulnerable source code that using unchecked \textit{strcpy()} or \textit{memcpy()} so that we can take advantage of this uncheck argument passing procedure.

Secondly, After we construct a vulnerable source code that containing unchecked \textit{strcpy()}, we write a exploit source code to conduct stack smashing. In this exploit suorce code, we construct the machine code of shellcode and our goal is to rewrite the return address to our shellcode's address. We need to insert this malicious code into the stack and make sure the stack is executable. So when we build the c source code, we set the compiler options as \textit{gcc -z execstack -fno-stack-protector} so that the stack can be executable and the stack canaries would be closed.

Finally, we use the gdb to debug the program and get the information of ebp, esp, return address, and shellcode's address. Based on these information, we can do some calculation to determine what should we pass to the tainted buffer in order to overflow the vulnerable variable. This process is shown in detail in the Wiki. 

When the project successfully return to our shellcode rather than the original main function, we know that our exploit works. And then, we turn on the ASLR and get segment fault erro when we run the same program. This is because the randomization of the address of heap, stack, code, and shared libraries can be achieved by ASLR. And when we trun ASLR off but enable stack canaries, this attack still cannot work since we change the value of stack canaries when we overflow the vulnerable variable in the stack, this will lead to the program triger the exception handle mechanism. To defeat the stack protected method, such as DEP, we need to use arc injection, which we will discribe in detail soon, to attack the program without requiring a executable stack.
  

\subsection{Implementing a stack smashing exploit that uses arc-injection}
Firstly, we know that this exploit is also a type of bufferoverflow attack. However, we don't need the stack to be executable in this case and we don't even need a shellcode. Instead, Instead, we let the vulnerable program jump to the existing code, such as the \textit{system()} function in the libc library that has been loaded into memory, to implement our attack. So similar to the code injection, we construct a vulnerable source code and build it, and construct an exploit source code and build it. In this case, we don't need to set the compiler option \textit{gcc -z exestack} since we would not insert any code into the stack.

Secondly, our goal is to let the vulnerable program jump to the \textit{system()} function and pass the \textit{/bin/sh} as argument. So we need to know the address of \textit{system()} and the address of environmental variable \textit{/bin/sh}. We can know the address of \textit{system()} by using \textit{p system} command in gdb since these functions are loaded into memory and their addresses are same for the all programs(we've already closed ASLR). And then we find the address of environmental variable \textit{/bin/sh} by \textit{getenv()}, or by using command \textit{x/500s \$esp} in gdb to find the address.

Finally, we test the exploit program and it works well. And we let the vulnerable program jump to the \textit{system()} and open the /bin/sh successfully. This process is shown in detail in the Wiki. We also know that the effective way to prevent our program from arc injection attack is to open the ASLR, since it will make the attck very difficult by randomize the addresses of shared library. However, there are some more complicated method to achieve the attack, such as chaining return-to-libc calls via frame-faking method.

\section{Findings}
\subsection{Implementing a stack smashing exploit that uses shellcode injection}
The basic idea of our code injection exploitation is that when a function is called, we modify its return address in the stack to the address which is our shellcode address. Therefore, we need to get the exact address in the stack to put in our shellcode. If the ASLR (Address Space Layout Randomization) is off, we can calculate the address to be attacked by executing the program for several times. If the ASLR is on, the address in the memory will be randomized every time the program being executed. Therefore, we cannot figure out the address in the memory by executing the program, which means our injection will fail.

In our case, we turn on ASLR after we successfully implement the code injection. When we want to replay what we do previously, we find that we cannot figure out the address where we want to insert our shellcode because the address will change after we re-execute our program.

There are several ways to defeat ASLR, one of which is brute force. \cite{defeating_tech} We need to try lots of addresses until it works.

\subsection{Implementing a stack smashing exploit that uses arc-injection}
When the system enables DEP (Data Execution Prevent), the stack is actually ``no-executable''.




\section{Conclusion}
In this homework, we learn the format string vulnerabilities and how to exploit these vulnerabilities on an open source command line application -- Webbench, which is a website performance testing tool. This process is tough for us at the very beginning. We have to learn the basic knowledge of how C program runs in the memory like how the stack works. We also read slides and books about format string vulnerabilities and how to exploit the vulnerabilities. The \textit{x86 Assembly Guide} \cite{x86_assemby_guide} and the \textit{Phrack} \cite{phrack} is very helpful. With the help of the materials and homework instructions, we start to modify the source code of Webbench to exploit format string vulnerabilities.

In conclusion, we get to know the usage of gdb. And we use it to exploit the format string vulnerabilities on WebBench. We implement an information leak exploit, buffer overflow exploit and an arbitrary write exploit.

This work is difficult but we have fun through the process.


\section{Appendix}
We put all supplementary information to the Wiki for our Gitlab project.

\begin{thebibliography}{10}
\bibitem{webbench_intro}
\"EZLippi/WebBench\", GitHub. [Online]. Available: https://github.com/EZLippi/WebBench.

\bibitem{x86_assemby_guide}
\"Guide to x86 Assembly\", Flint.cs.yale.edu. [Online]. Available: http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html.

\bibitem{phrack}
\".:: Phrack Magazine ::.\", Phrack.org. [Online]. Available: http://phrack.org/issues/49/1.html.

\bibitem{v_format_string}
\"A simple Format String exploit example - bin 0x11\", YouTube, 2016. [Online]. Available: https://www.youtube.com/watch?v=0WvrSfcdq1I.

\bibitem{defeating_tech}
N. Stack Overflows - Defeating Canaries, ``Stack Overflows - Defeating Canaries, ASLR, DEP, NX'', Security.stackexchange.com. [Online]. Available: https://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx.
\end{thebibliography}


\end{document}