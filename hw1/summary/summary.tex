\documentclass[journal]{IEEEtran}


% ------------ package ------------
\usepackage{graphicx}
\graphicspath{{public/}}
% ------------ package end ------------

\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

% ------------ title ------------
\title{Summar1y Report}
\author{Qiyang~Gu, Ujjawal~Sharma, Zhiyuan~Li}
\maketitle
% ------------ title end ------------


% ------------ abstract ------------
\begin{abstract}
Threat modeling is a technique meant to build secure systems by searching for the potential threats in systems. The concepts of threat model are based on assets which are worth being protected. These assets have specific vulnerabilities which can be exploited by attackers. Security analysts can identify which component in a system that would have the highest risk of being attacked by thinking from the perspective of the attacker. These components should have highest priorities in security assessments. Database is an essential and very significant part in an enterprise. It contains pivotal information about whole system and always become the target of attackers. In this report we choose on open-source database engine SQLite, following the threat modeling process of Microsoft, and create a threat model for SQLite.
\end{abstract}
% ------------ abstarct end ------------

% ------------ keywords ------------
\begin{IEEEkeywords}
sqlite3, database, threat modeling
\end{IEEEkeywords}
% ------------ keywords end ------------



\section{Introduction to sqlite}
\IEEEPARstart{S}QLite is a lightweight open source SQL database engine, written totally by C.  It is self-contained, serverless, zero-configuration and transcational. It takes up very few resources when running.  Not only it can support different operating systems like Windows/Linux/Unix, but also it can be easily integrated with different programming languages like Java/PHP/C\#. What's more, compares to MySQL and PostgreSQL, the world's most famous open-source database engines, SQLite has a better performance on query. It has been 17 years since the alpha version of SQLite released in May 2000. Now, SQLite3 is pre-installed in almost all the Linux systems, as well as the latest macOS.


\section{Highlights on SQLite}
\subsection{Lightweight}
When optimized for size, the whole SQLite library with all features enabled is less than 500KiB in size. Unneeded features can be disabled at compile-time to further reduce the size of the library to under 300KiB if desired.

\subsection{Independence}
SQLite has very few dependencies. It can run on any operating systems. SQLite uses no external libraries or interfaces.

\subsection{Transactionality}
All changes and queries in SQLite are Atomic, Consistent, Isolated, and Durable (ACID). All changes within a single transaction in SQLite either occur completely or not at all, even if the act of writing the change out to the disk is interrupted by program/OS crash or power failure.

\subsection{Serverlessness}
SQLite does not have a separte server process like MySQL does. Without communicating with the server process, SQLite reads and writes data directly from a database file on local disk.

\subsection{Single database file}
An SQLite database is a single ordinary disk file that can be located anywhere in the directory hierarchy. There are no mutiple files or other dependencies. A single database file contains everything in the database

\subsection{Cross-Platform Database File}
A database file written on one machine can be copied to and used on a different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter.

\subsection{Manifest Typing}
In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite allows the user to store any value of any datatype into any column regardless of the declared type of that column.

\subsection{Easy API}
The core API is small, simple, and easy to learn. Two objects and eight methods comprise the essential elements of the SQLite interface.


\section{Accomplished \& Unaccomplished}
\subsection{Accomplished}
\subsubsection{}
Designed to be used in embedded systems, SQLite is very lightweight so that it take up very few system resources when running.

\subsubsection{}
The performance of reading/writing is high in embedded systems.

\subsubsection{}
ACID (Atomic, Consistent, Isolated, and Durable) transactions are enabled.

\subsubsection{}
User can freely copy the database file from one system to another.

\subsubsection{}
Users can easily use the APIs it provides.

\subsubsection{}
Most of mainstream programing languages support SQLite. It is convient for developers.


\subsection{Unaccomplished}
\subsubsection{}
User systems. (Different users should have different levels of privilege to certain table.)

\subsubsection{}
Stable Journaling file system.

\subsubsection{}
Good performance on writing operation. (Insert, Update, etc)

\subsubsection{}
Good performance on high concurrency and large data.

\subsubsection{}
Separte deployment of database. (SQLite use single database file.)


\section{Architecture}
SQLite has a delicate architecture. It consists of eight independent modules in three sub-systems.
\subsection{Overview}
\begin{figure}[!htbp]
\centering
\includegraphics[height=7cm]{arch_and_module}
\caption{Modules}
\end{figure}

\subsection{Modules}
\subsubsection{Front-end Interface}
The user or program interacts with database file via front-end interface.

\subsubsection{Tokenizer}
Tokenizer accpets SQL statements transmitted by front-end interface. It will split the statements into tokens. And then, these tokens will be sent to parser.

\subsubsection{Parser}
Parser will assign each token a specific meaning accord to the context.

\subsubsection{Code Generator}
Code generator will generate codes according to what parser returns.

\subsubsection{Virtual Machine}
All the codes will be executed by virtual machine.

\subsubsection{B-Tree}
The database file will store on the disk in form of B-tree.

\subsubsection{Page Cache}
The B-tree module request data blocks from local disk. Page cache is responsible for reading/writing/caching these data blocks.

\subsubsection{OS Interface}
In order to meet the requirement of portability, SQLite use a OS interface module to support POSIX or Win32. There are different implements in source codes according to operating systems. (os\_unix.c for Unix, os\_win.c for Windows, etc.)


\section{Conclusion}
SQLite is a popular open-source database engine. It is very lightweight meanwhile its performance is great. Many small and medium-sized websites prefer to use SQLite as their database. However, it's lightweight feature also brings many security issues. We cannot expect such a small database engine offers great secure policies. \\
During the process of threat modeling, we identify the assets, decomposing the whole application, identifying the threats and valuing these threats. We also come up with some mitigations for these threads. \\ 
It's not easy work for our green-hand students. However, after finishing the whole assignment, we have learnt how to consider more detailedly when building a software. \\ 
All the supplementary images are attached in a PDF file called \'Threat modeling deliverables\'.

\begin{thebibliography}{10}
\bibitem{q1}
Ray, Indrajit, et al., eds.Â Information Systems Security: 12th International Conference, ICISS 2016, Jaipur, India, December 16-20, 2016, Proceedings. Vol. 10063. Springer, 2016.
\bibitem{q2}
2014, Shostack, Threat Modeling: Designing for Security
\bibitem{q3}
Michael Owens. 2003. Embedding an SQL database with SQLite. Linux J. 2003, 110 (June 2003), 2-.
\bibitem{q4}
Offical documentation, https://www.sqlite.org/docs.html
\bibitem{q5}
SQLite source code analysis, http://huili.github.io/
\end{thebibliography}

\end{document}